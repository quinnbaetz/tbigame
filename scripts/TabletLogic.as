package tbigame.scripts {	import flash.display.MovieClip;	import flash.display.MovieClip;	import fl.transitions.Tween;	import fl.transitions.easing.*;	import fl.transitions.TweenEvent;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.TextFieldAutoSize;	import flash.display.Bitmap;	import flash.display.Sprite;	import flash.utils.getDefinitionByName;	import flash.events.MouseEvent;	import flash.ui.Keyboard;	import flash.events.KeyboardEvent;	import flash.external.ExternalInterface;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.events.*;	import fl.controls.RadioButton;		public class TabletLogic extends MovieClip{				/*****************************************		************    CONSTANTS     ************		******************************************		*/				private var glossary = {}						/************************		**************************************		***************************************************************		************************************************************************************************		*/				//CLASS VARS		//public var tabletContent;		public var theStage;		public var scope;		private var padX = -105;		private var padY = 420;		private var padRot = 30;		private var scale = .4;		public var pad;		public var inToolbox;						//Eventually taken as a param? Some way to differentiate..		private var classVersion:Boolean = false;				//FLAGS		private var ctReportIsOn:Boolean = false;				//CT-Report Array, index inputs --		//Indexes strings by diagnosis, then location, then summary		//top down, left to right		public var ctReportArr:Array;		//Store the string for second CT page separately.		public var ctRecommendStr:String;				private var ctrIndexMem:Array;		private var ctrRadMem:Array;		private var ctCallback:Function;		private var errCall:Function;				private var ctRadioButtonGroups = [];		private var ctRadButtons = ["Diffuse", "Mass","Foreign","Hematoma","Concussion","Normal","Right","Left","Subdural","Epidural","Temporal","Parietal","Occiptal", "Frontal"];		private var ctFirstRadButtons = ["Left", "Frontal","Normal", "Subdural"];		private var glossaryTerms = [];		private var ctDropDowns = ['blood', 'rightCB', 'hematomaCB', 'temporalCB', 'crescent', 'subduralCB', 'brain', 'brain2'];		//---				public function TabletLogic(theStage, scope, myToolbox) {			this.theStage = theStage;			this.scope = scope;						ctReportArr = new Array();			ctrIndexMem = new Array(8);			ctrRadMem = new Array(4);			//set parameters for tablet			this.pad = new Tablet();			this.pad.x = padX;			this.pad.y = padY;			this.pad.scaleX = scale;			this.pad.scaleY = scale;			this.pad.rotation = padRot;									//hide unused buttons			this.pad.EMTnoteButton.visible = false;			this.pad.CTscanNoteButton.visible = false;			this.pad.SurgeryNoteButton.visible = false;						this.pad.AdmissionReportButton.visible = false;			this.pad.CTreportButton.visible = false;			this.pad.SurgeryReportButton.visible = false;						this.pad.ProgressButton.visible = false;									//tabletContent is embedded within the tablet movieClip now			this.scope.addCache(this.pad, this.theStage);						this.pad.tabletContent.gotoAndStop("CT_Scan_Report_1");						//grab the groups that contain the radiobuttons			for each(var radioButton in ctFirstRadButtons){				var group = this.pad.tabletContent[radioButton].group;				ctRadioButtonGroups.push(group);								group.addEventListener(Event.CHANGE, function(event){					for(var i in ctRadioButtonGroups){						if(event.currentTarget == ctRadioButtonGroups[i]){							if(event.currentTarget.selectedData === null){								trace("return succeeded");								return;							}							trace("return failed if ", event.currentTarget.selectedData);							ctrRadMem[i] = event.currentTarget.selectedData;							if(i === 2){								if(event.currentTarget.selectedData !== "Hematoma"){									if(typeof(ctrRadMem[3]) !== "undefined"){										ctrRadMem[3] = undefined;										ctRadioButtonGroups[3].selection = null;										//possibly remove button here										ctRadioButtonGroups[3].removeEventListener(Event.CHANGE, arguments.callee);										var tempBtn:RadioButton = new RadioButton(); 										tempBtn.group = ctRadioButtonGroups[3]; 										tempBtn.selected = true; 										ctRadioButtonGroups[3].removeRadioButton(tempBtn);										ctRadioButtonGroups[3].addEventListener(Event.CHANGE, arguments.callee);									}								}							}							if(i === 3){								ctRadioButtonGroups[2].removeEventListener(Event.CHANGE, arguments.callee);								ctrRadMem[2] = that.pad.tabletContent.Hematoma.value;								ctRadioButtonGroups[2].selection = that.pad.tabletContent.Hematoma;								that.pad.tabletContent.Hematoma.selected = true;								ctRadioButtonGroups[2].addEventListener(Event.CHANGE, arguments.callee);							}													}					}				});							}									this.pad.tabletContent.gotoAndStop("defaultScreen");			this.inToolbox = myToolbox;						//set up glossary definitions			var terms = scope._('glossary terms');			for(var i in terms){				glossary[terms[i]] = scope._(terms[i]+" entry");				trace(terms[i] + " " + glossary[terms[i]]);			}			addSearchEvtListeners();			this.pad.tabletContent.stop();												var that = this;			var lastFrame = -1;									this.pad.tabletContent.addEventListener(Event.ENTER_FRAME, function(){				if(that.pad.tabletContent.currentFrame==lastFrame){					return;				}				lastFrame = that.pad.tabletContent.currentFrame;				trace("tablet scene switch");				if(lastFrame!=2){					that.hideResults();				}				//if on the ct scene				if(lastFrame === 4){															for(var i in ctRadioButtonGroups){						if(ctrRadMem[i]){							for each(var rad in ctRadButtons){								if(that.pad.tabletContent[rad].value == ctrRadMem[i]){									ctRadioButtonGroups[i].selection = that.pad.tabletContent[rad];									that.pad.tabletContent[rad].selected = true;									break;									//trace("------", ctrRadMem[i]);								}							}							//ctrRadMem[i].selected = true;						}																	}										for(var i in ctDropDowns){						//set to what it was before						if(typeof(ctrIndexMem[i]) !== "undefined"){							that.pad.tabletContent[ctDropDowns[i]].removeItemAt(0);							that.pad.tabletContent[ctDropDowns[i]].selectedIndex = ctrIndexMem[i];						}												//get rid of top empty on click						that.pad.tabletContent[ctDropDowns[i]].addEventListener(MouseEvent.CLICK, function(event){							if(event.currentTarget.dataProvider.getItemAt(0).label === ""){								event.currentTarget.dataProvider.removeItemAt(0);								for(var i in ctDropDowns){									if(event.currentTarget == that.pad.tabletContent[ctDropDowns[i]]){										 ctrIndexMem[i] = 0;									}								}															}						});						//record when change happens for drop downs						that.pad.tabletContent[ctDropDowns[i]].addEventListener(Event.CHANGE, function(event){							for(var i in ctDropDowns){								if(event.currentTarget == that.pad.tabletContent[ctDropDowns[i]]){									 ctrIndexMem[i] = event.currentTarget.selectedIndex;									 trace(ctrIndexMem[i]);								}							}						});																	}				}							});		}				//necessary for managing the Glossary		private function addSearchEvtListeners() {						this.pad.SearchInput.addEventListener(MouseEvent.CLICK, termSearch);			this.pad.SearchInput.addEventListener(KeyboardEvent.KEY_DOWN, termSearch);			this.pad.SearchInput.stage.focus = this.pad.SearchInput;			this.pad.SearchInput.setSelection(0,0);			sideMenuListeners();		}						//public wrapper for the actual toggle function		public function padToggle(evt, forceOpen = false, forceClose = false) {			tabletToggle(evt, forceOpen, forceClose);		}				/**		* Hides tablet from view		*/		public function hide(){			this.pad.buttonMode = false;			this.pad.useHandCursor = false;			this.pad.alpha = 0;		}		/**		* Shows tablet		*/		public function show(){			this.pad.buttonMode = true;			this.pad.useHandCursor = true;			this.pad.alpha = 1;		}				//This will toggle the availability of CT Report scene		public function toggleCtReport(callback:Function, errorCallback:Function):void {			if(ctReportIsOn){				this.pad.CTreportButton.visible = false;				ctReportIsOn = false;			}			else {				this.pad.CTreportButton.visible = true;				//hack to get it to render properly				this.pad.CTreportButton.width = this.pad.CTreportButton.width+1;				ctReportIsOn = true;			}			ctCallback = callback;			errCall = errorCallback;		}						private function CTR2toArr():void {			//two cases, one for in class use.			if(!classVersion){				ctRecommendStr = this.pad.tabletContent.CERformprefilled.text;			} else {				ctRecommendStr = this.pad.tabletContent.CERform.text;			}					}				//adds one listener for now  -- 		//todo: will eventually add listeners to the whole side menu		private function sideMenuListeners():void {			this.pad.CTreportButton.addEventListener(MouseEvent.MOUSE_DOWN, toCTReport);		}						/**		* Hides all elements of searchList		*/		private function hideResults():void {			for(var i in glossaryTerms){				this.scope.remove(glossaryTerms[i]);			}			glossaryTerms = [];		}				/* triggered when clicked on search. We take the entered string and see if it is a substring from the list of		 * valid entries		 */		private function termSearch(event) {			var that = this;			scope.defer(function(){				trace("made it here", that, that.pad);				displayQueryResult(that.pad.SearchInput.text);			});		}				/*		* Opposite of hideResults		*/		private function displaySearchTerm(text, num):void {			var myFormat:TextFormat = new TextFormat();			myFormat.size = 14;						var mc = new MovieClip();			var myText:TextField = new TextField();			myText.defaultTextFormat = myFormat;			myText.text = text;			this.scope.addCache(mc, this.pad.tabletContent);			this.scope.addCache(myText, mc);			mc.myText = myText;			//mc.width = 300;			//mc.height = 21;			mc.mouseChildren = false;			myText.width = 300;			myText.height = 21;			mc.x = -60;			mc.y = -76 + 22*num;			if(num>=19){				mc.x += 300;				mc.y -= 22*19;			}						num++;			mc.addEventListener(MouseEvent.CLICK, displayDescription);			glossaryTerms.push(mc);		}				/**		* Uses indexOf to check for subStrings. hideResults will first set		* all elements invisible, and if indexOf spots match it will reveal it.		*/		private function displayQueryResult(queryStr:String):void {			trace("blah");			this.pad.tabletContent.gotoAndStop("searchList");			hideResults();			var numFound:int = 0;			queryStr = queryStr.toLowerCase();			trace("string of query is: " + queryStr);						for(var term in glossary){				if(term.toLowerCase().indexOf(queryStr) >= 0 ){					displaySearchTerm(term, numFound);					numFound++;				}			}						if(numFound == 0) {				//call again using empty to display all				displayQueryResult('');			}		}				private function tabletToggle(evt, forceOpen = false, forceClose = false): void {			trace("here");			inToolbox.bringForward();						if((pad.x<-50 || forceOpen) && !forceClose){				trace("opening");				this.inToolbox.hideMenu();				this.scope.createTween(pad, "x", None.easeInOut, 20);				this.scope.createTween(pad, "y", None.easeInOut, 5);				this.scope.createTween(pad, "scaleX", None.easeInOut, 1);				this.scope.createTween(pad, "scaleY", None.easeInOut, 1);				this.scope.createTween(pad, "rotation", None.easeInOut, 0, -1, 10, function(){					//ExternalInterface.call("showTabletContent");				});				return;			}			if(pad.x>=-50 || forceClose){				trace("closing");				var myTimer:Timer = new Timer(250, 1);				myTimer.start();				var scope = this.scope;				myTimer.addEventListener(TimerEvent.TIMER_COMPLETE, function(){					myTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, arguments.callee);					myTimer = null;					scope.createTween(pad, "x", None.easeInOut, padX);					scope.createTween(pad, "y", None.easeInOut, padY);					scope.createTween(pad, "scaleX", None.easeNone, scale);					scope.createTween(pad, "scaleY", None.easeNone, scale);					scope.createTween(pad, "rotation", None.easeInOut, padRot);				 });				 //ExternalInterface.call("hideTabletContent");			} 		}//end toggle function				//when a user clicks a link from search, this is where it goes..		private function displayDescription(event:MouseEvent):void {						this.pad.tabletContent.gotoAndStop("descriptionField");						this.pad.tabletContent.ReturnSearchButton.addEventListener(MouseEvent.CLICK, termSearch);			pad.tabletContent.DescriptionField.text = glossary[event.currentTarget.myText.text];			pad.tabletContent.termName.text = event.currentTarget.myText.text;		}				//Listener for CT Report button		private function toCTReport(event:MouseEvent):void {			if(ctReportIsOn) {				this.pad.tabletContent.gotoAndStop("CT_Scan_Report_1");				this.pad.tabletContent.NextPage.addEventListener(MouseEvent.CLICK, nextPageCTR);			}		}				private function submitReport(event:MouseEvent):void {			CTR2toArr();						//TODO: How to escape and move on? Not immediatelys sure..			ctCallback();		}		private function isFormFilled(){			trace(ctrRadMem, ctrIndexMem.length);			for(var i = 0; i<ctrIndexMem.length; i++){				trace("-----", typeof(ctrIndexMem[i]), ctrIndexMem[i]);				if(typeof(ctrIndexMem[i]) === "undefined"){					return false;				}			}			var len = ctrRadMem.length-1;			//to account for the missing radio button			trace("oooo", ctrRadMem[2], ctrRadMem[3])			if(ctrRadMem[2] === "Hematoma"){				trace("len upping");				len++;			}			for(var i = 0; i<len; i++){				if(typeof(ctrRadMem[i]) === "undefined"){					return false;				}			}			return true;		}				private function nextPageCTR(event:MouseEvent):void {						trace("here");			if(!isFormFilled()) {				errCall();				return;			}						//two cases, one for in class use.			if(!classVersion){				this.pad.tabletContent.gotoAndStop("CT_Scan_Report_2");				this.pad.tabletContent.CTreportSubmit2.addEventListener(MouseEvent.CLICK, submitReport);			} else {				this.pad.tabletContent.gotoAndStop("CT_Scan_Report_2class");				this.pad.tabletContent.CTreportSubmit3.addEventListener(MouseEvent.CLICK, submitReport);			}									//we need to get back!			this.pad.tabletContent.previousPage.addEventListener(MouseEvent.CLICK, toCTReport);		}			}	}