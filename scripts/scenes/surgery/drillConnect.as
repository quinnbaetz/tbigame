import flash.display.MovieClip;import flash.geom.Point;(function(){ 	var ErrorMargin = 10//15;    var mX = 317;	var mY = 165;	var pOutline =  addImage("headLinesRegion", mX-6, mY-10);	var pMarker =  addImage("headLines", mX-11, mY-11);	var pMarkerLine =  addImage("skullBone", mX, mY);			var sugeonDialogError = function(callback){		var messages = new Array("If you have trouble connecting the keyholes, take a break and try again, we need to be a precise as possible.");		var msgs = displayMessages(messages, 50, 60, callback, false, "surgeonFace");	}				pMarker.alpha = 0;	pOutline.alpha = 0;	bringToFront(stage, pDrillArm);	toolbox.bringForward();	createTween(pMarker, "alpha", None.easeInOut, .8, -1, 100);	var fadeLines = function(callback){		var tweens = new Array();		var waiter = null;		tweens.push(createTween(pDrillArm, "y", None.easeInOut, 0, -1, 100));		tweens.push(createTween(pDrillArm, "x", None.easeInOut, WIDTH, -1, 100));		//tweens.push(createTween(pOutline, "alpha", None.easeInOut, 0, -1, 100, function(){		tweens.push(createTween(pMarker, "alpha", None.easeInOut, 0, -1, 100, function(){			waiter.kill();			callback();		}));				waiter = waitOnUser(function(){			for(var i in tweens){				tweens[i].fforward();				tweens[i] = null;			}			tweens = null;		});			}		var withinBounds = function(x, y){		//return pOutline.hitTestPoint(x, y, true);		var bmapData:BitmapData = new BitmapData(pOutline.width, pOutline.height, true, 0x00000000);		bmapData.draw(pOutline, new Matrix());		var point = new Point(x,y);		var returnVal:Boolean = bmapData.hitTest(new Point(0,0), 0, pOutline.globalToLocal(point));		bmapData.dispose();		return returnVal;	}		var lastPt = {};	var startPt = {};	var pointTouch = new Array(false, false, false, false);		var task = 0;	var startingPt;		var userLine = new MovieClip();		userLine.graphics.beginFill(0xFF0000);	pMarkerLine.mask = userLine;			userLine.x = 0;	userLine.y = 0;		var checkDrawFunc = function(callback){			var checkPoints = new Array({x: 494, y: 191},{x: 458, y: 181},{x: 419, y: 171},{x: 383, y: 172},{x: 349, y: 185},{x: 328, y: 206},{x: 321, y: 234},{x: 325, y: 288},{x: 347, y: 324},{x: 376, y: 343},{x: 415, y: 357},{x: 452, y: 360},{x: 516, y: 342},{x: 535, y: 328},{x: 553, y: 307},{x: 560, y: 259},{x: 547, y: 229})			//var misses = 0;			for(var i in checkPoints){				var point:Point = new Point(checkPoints[i].x, checkPoints[i].y);				   				 if (!pMarkerLine.hitTestPoint(point.x, point.y, true)){					//misses++;					//if(misses>0){						trace("{x: "+point.x+", y: "+point.y+"},");  						return;					//}				}			}			if(typeof callback === "function"){				callback();			}			}		var markerDraw = timer(25, function(){		var mousex = mousePos.x;		var mousey = mousePos.y;		switch(task){			case 0:								//waiting for user to go inside lines				 lastPt.x = pDrillArm.x+50;				 lastPt.y = pDrillArm.y+pDrillArm.height-40;				if(withinBounds(lastPt.x, lastPt.y)){					userLine.graphics.drawCircle(lastPt.x, lastPt.y, 8);					task = 1;					startPt.x = lastPt.x;					startPt.y = lastPt.y;				}   			break;			case 1:				if(withinBounds(mousex, mousey)){				   lastPt.x = pDrillArm.x+50;				   lastPt.y = pDrillArm.y+pDrillArm.height-40;				   //userLine.graphics.lineTo(lastPt.x, lastPt.y);				   userLine.graphics.drawCircle(lastPt.x, lastPt.y, 8);				  				  	checkDrawFunc(function(){ 				  					   var dist = hypot((startPt.x)-lastPt.x, (startPt.y)-(lastPt.y));					   if(dist<15){							task=-1;							markerDraw.stop();							if(clipHandMove){								clipHandMove.stop();								trace("hand stop moving");							}							markerDraw = null;							clipHandMove = null;														tweenX.stop();							tweenY.stop();							stage.removeEventListener(MouseEvent.MOUSE_MOVE,getMousePos);							fadeLines(function(){								stage.removeChild(pOutline);								stage.removeChild(pMarker);								stage.removeChild(pMarkerLine);								stage.removeChild(holes);								stage.removeChild(pDrillArm);								lastFrame = -1;								gotoAndStop("Scene_SurgeryPatient");							});						}					});				}else{					task = -1;					//if(firstLoss){						clock.reduceAngle(20);						sugeonDialogError(function(){							task = 0;						});					//	firstLoss = false;					//}					//userLine.graphics.clear();					/*var myStart = {x: lastPt.x, y: lastPt.y}					setTimeout(function(){						task=0;						if(startingPt === true){							startPt.x = myStart.x; 							startPt.y = myStart.y; 						}else{							endPt.x = myStart.x; 							endPt.y = myStart.y;						}					}, 300);										surgeonDialog();*/				}						break;					}			}, 0);	})();